package main

import (
	"fmt"
	"path"
	"path/filepath"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".ts"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-veloce. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()

	g.P(`import { VeloceClient } from "@vlce/veloce-client";`)
	g.P(`import type { RequestOptions } from "@vlce/veloce-client";`)
	g.P()

	// Collect used types in this file to filter dependency imports
	usedTypes := make(map[string]bool)
	var collectUsedTypes func(messages []*protogen.Message)
	collectUsedTypes = func(messages []*protogen.Message) {
		for _, msg := range messages {
			for _, field := range msg.Fields {
				if field.Desc.IsMap() {
					valField := field.Message.Fields[1]
					if valField.Message != nil {
						usedTypes[valField.Message.GoIdent.GoName] = true
					}
				} else if field.Message != nil {
					usedTypes[field.Message.GoIdent.GoName] = true
				}
			}
			collectUsedTypes(msg.Messages) // traverse nested messages
		}
	}
	collectUsedTypes(file.Messages)

	for _, service := range file.Services {
		for _, method := range service.Methods {
			usedTypes[method.Input.GoIdent.GoName] = true
			usedTypes[method.Output.GoIdent.GoName] = true
		}
	}

	// Generate Imports for Dependencies
	imports := file.Desc.Imports()
	hasImports := false
	for i := 0; i < imports.Len(); i++ {
		imp := imports.Get(i)
		dep := gen.FilesByPath[imp.Path()]
		if dep == nil {
			continue
		}
		var importedNames []string
		var collectImportNames func(messages []*protogen.Message)
		collectImportNames = func(messages []*protogen.Message) {
			for _, msg := range messages {
				if usedTypes[msg.GoIdent.GoName] {
					importedNames = append(importedNames, msg.GoIdent.GoName)
				}
				collectImportNames(msg.Messages) // traverse nested messages
			}
		}
		collectImportNames(dep.Messages)

		if len(importedNames) > 0 {
			dir := path.Dir(file.GeneratedFilenamePrefix)
			rel, err := filepath.Rel(filepath.FromSlash(dir), filepath.FromSlash(dep.GeneratedFilenamePrefix))
			if err == nil {
				rel = filepath.ToSlash(rel)
				if !strings.HasPrefix(rel, ".") && !strings.HasPrefix(rel, "/") {
					rel = "./" + rel
				}
				importPath := rel + ".js"
				g.P(fmt.Sprintf("import type { %s } from \"%s\";", strings.Join(importedNames, ", "), importPath))
				hasImports = true
			}
		}
	}
	if hasImports {
		g.P()
	}

	// Generate Messages (Interfaces)
	var generateAllMessages func(messages []*protogen.Message)
	generateAllMessages = func(messages []*protogen.Message) {
		for _, msg := range messages {
			if msg.Desc.IsMapEntry() {
				continue
			}
			generateMessage(g, msg)
			generateAllMessages(msg.Messages)
		}
	}
	generateAllMessages(file.Messages)

	// Generate Services (Classes)
	for _, service := range file.Services {
		generateService(g, service)
	}
}

func generateMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	fullName := string(msg.Desc.FullName())
	if strings.HasPrefix(fullName, "google.protobuf.") {
		switch string(msg.Desc.Name()) {
		case "Timestamp", "Duration", "StringValue", "BytesValue", "FieldMask":
			g.P("export type ", msg.GoIdent.GoName, " = string;")
			g.P()
			return
		case "Int32Value", "UInt32Value", "Int64Value", "UInt64Value", "FloatValue", "DoubleValue":
			g.P("export type ", msg.GoIdent.GoName, " = number;")
			g.P()
			return
		case "BoolValue":
			g.P("export type ", msg.GoIdent.GoName, " = boolean;")
			g.P()
			return
		case "Struct":
			g.P("export type ", msg.GoIdent.GoName, " = { [key: string]: any };")
			g.P()
			return
		case "Value":
			g.P("export type ", msg.GoIdent.GoName, " = any;")
			g.P()
			return
		case "ListValue":
			g.P("export type ", msg.GoIdent.GoName, " = any[];")
			g.P()
			return
		case "Empty":
			g.P("export type ", msg.GoIdent.GoName, " = {};")
			g.P()
			return
		case "Any":
			g.P("export type ", msg.GoIdent.GoName, " = { '@type': string; [key: string]: any };")
			g.P()
			return
		}
	}

	g.P("export interface ", msg.GoIdent.GoName, " {")
	for _, field := range msg.Fields {
		tsType := getTSType(field)
		opt := ""
		if field.Desc.HasOptionalKeyword() || field.Desc.IsList() {
			opt = "?" // simplistic optional handling
		}
		g.P("  ", field.Desc.JSONName(), opt, ": ", tsType, ";")
	}
	g.P("}")
	g.P()
}

func getTSType(field *protogen.Field) string {
	if field.Desc.IsList() {
		return getBaseTSType(field) + "[]"
	}
	if field.Desc.IsMap() {
		return "{ [key: string]: " + getBaseTSType(field.Message.Fields[1]) + " }"
	}
	return getBaseTSType(field)
}

func getBaseTSType(field *protogen.Field) string {
	switch field.Desc.Kind().String() {
	case "bool":
		return "boolean"
	case "int32", "uint32", "sint32", "fixed32", "sfixed32", "float", "double":
		return "number"
	case "int64", "uint64", "sint64", "fixed64", "sfixed64", "string":
		return "string"
	case "bytes":
		return "Uint8Array | string" // Using string for base64
	case "message":
		return field.Message.GoIdent.GoName
	case "enum":
		return "string | number"
	default:
		return "any"
	}
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("export class ", service.GoName, "Client {")
	g.P("  constructor(private readonly client: VeloceClient) {}")
	g.P()

	for _, method := range service.Methods {
		generateMethod(g, method)
	}

	g.P("}")
	g.P()
}

func generateMethod(g *protogen.GeneratedFile, method *protogen.Method) {
	httpExt := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
	rule, ok := httpExt.(*annotations.HttpRule)

	httpMethod := "POST"
	path := fmt.Sprintf("/%s/%s", method.Parent.Desc.FullName(), method.Desc.Name()) // fallback
	body := ""

	if ok && rule != nil {
		switch pattern := rule.Pattern.(type) {
		case *annotations.HttpRule_Get:
			httpMethod = "GET"
			path = pattern.Get
		case *annotations.HttpRule_Post:
			httpMethod = "POST"
			path = pattern.Post
		case *annotations.HttpRule_Put:
			httpMethod = "PUT"
			path = pattern.Put
		case *annotations.HttpRule_Delete:
			httpMethod = "DELETE"
			path = pattern.Delete
		case *annotations.HttpRule_Patch:
			httpMethod = "PATCH"
			path = pattern.Patch
		}
		body = rule.Body
	}

	reqType := method.Input.GoIdent.GoName
	respType := method.Output.GoIdent.GoName

	g.P("  async ", method.Desc.Name(), "(request: ", reqType, ", options?: RequestOptions): Promise<", respType, "> {")

	g.P("    const path = `", replacePathVars(path), "`;")

	if httpMethod == "GET" || httpMethod == "DELETE" {
		g.P("    return this.client.request<", respType, ">(path, '", httpMethod, "', undefined, request, options);")
	} else {
		if body == "*" {
			g.P("    return this.client.request<", respType, ">(path, '", httpMethod, "', request, undefined, options);")
		} else if body != "" {
			g.P("    const bodyObj = (request as any).", snakeToCamel(body), ";")
			g.P("    return this.client.request<", respType, ">(path, '", httpMethod, "', bodyObj, request, options);")
		} else {
			g.P("    return this.client.request<", respType, ">(path, '", httpMethod, "', request, undefined, options);")
		}
	}
	g.P("  }")
	g.P()
}

func replacePathVars(path string) string {
	var res strings.Builder
	inVar := false
	var buf string

	for _, r := range path {
		switch r {
		case '{':
			inVar = true
			res.WriteString("${(request as any).")
		case '}':
			inVar = false
			parts := strings.Split(buf, ".")
			for i, p := range parts {
				parts[i] = snakeToCamel(p)
			}
			tsVar := strings.Join(parts, ".")
			res.WriteString(tsVar + "}")
			buf = ""
		default:
			if inVar {
				buf += string(r)
			} else {
				res.WriteString(string(r))
			}
		}
	}
	return res.String()
}

func snakeToCamel(s string) string {
	var res strings.Builder
	capitalizeNext := false
	for _, c := range s {
		if c == '_' {
			capitalizeNext = true
		} else {
			if capitalizeNext {
				res.WriteString(strings.ToUpper(string(c)))
				capitalizeNext = false
			} else {
				res.WriteString(string(c))
			}
		}
	}
	return res.String()
}
